/**
    Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.
*/

var Q = require('q');
var fs = require('fs');
var path = require('path');
var shell = require('shelljs');
var xcode = require('xcode');
var unorm = require('unorm');
var plist = require('plist');
var URL = require('url');
var events = require('cordova-common').events;
var xmlHelpers = require('cordova-common').xmlHelpers;
var ConfigParser = require('cordova-common').ConfigParser;
var CordovaError = require('cordova-common').CordovaError;
var projectFile = require('./projectFile');
var configMunger = require('./configMunger');
var FileUpdater = require('cordova-common').FileUpdater;

/*jshint sub:true*/

module.exports.prepare = function (cordovaProject, options) {
    var self = this;

    this._config = updateConfigFile(cordovaProject.projectConfig,
        configMunger.get(this.locations.root), this.locations);

    // Update own www dir with project's www assets and plugins' assets and js-files
    return Q.when(updateWww(cordovaProject, this.locations))
    .then(function () {
        // update project according to config.xml changes.
        return updateProject(self._config, self.locations);
    })
    .then(function () {
        updateIcons(cordovaProject, self.locations);
        updateSplashScreens(cordovaProject, self.locations);
    })
    .then(function () {
        events.emit('verbose', 'Prepared iOS project successfully');
    });
};

module.exports.clean = function (options) {
    // A cordovaProject isn't passed into the clean() function, because it might have
    // been called from the platform shell script rather than the CLI. Check for the
    // noPrepare option passed in by the non-CLI clean script. If that's present, or if
    // there's no config.xml found at the project root, then don't clean prepared files.
    var projectRoot = path.resolve(this.root, '../..');
    var projectConfigFile = path.join(projectRoot, 'config.xml');
    if ((options && options.noPrepare) || !fs.existsSync(projectConfigFile) ||
            !fs.existsSync(this.locations.configXml)) {
        return Q();
    }

    var projectConfig = new ConfigParser(this.locations.configXml);

    var self = this;
    return Q().then(function () {
        cleanWww(projectRoot, self.locations);
        cleanIcons(projectRoot, projectConfig, self.locations);
        cleanSplashScreens(projectRoot, projectConfig, self.locations);
    });
};

/**
 * Updates config files in project based on app's config.xml and config munge,
 *   generated by plugins.
 *
 * @param   {ConfigParser}   sourceConfig  A project's configuration that will
 *   be merged into platform's config.xml
 * @param   {ConfigChanges}  configMunger  An initialized ConfigChanges instance
 *   for this platform.
 * @param   {Object}         locations     A map of locations for this platform
 *
 * @return  {ConfigParser}                 An instance of ConfigParser, that
 *   represents current project's configuration. When returned, the
 *   configuration is already dumped to appropriate config.xml file.
 */
function updateConfigFile(sourceConfig, configMunger, locations) {
    events.emit('verbose', 'Generating platform-specific config.xml from defaults for iOS at ' + locations.configXml);

    // First cleanup current config and merge project's one into own
    // Overwrite platform config.xml with defaults.xml.
    shell.cp('-f', locations.defaultConfigXml, locations.configXml);

    // Then apply config changes from global munge to all config files
    // in project (including project's config)
    configMunger.reapply_global_munge().save_all();

    events.emit('verbose', 'Merging project\'s config.xml into platform-specific iOS config.xml');
    // Merge changes from app's config.xml into platform's one
    var config = new ConfigParser(locations.configXml);
    xmlHelpers.mergeXml(sourceConfig.doc.getroot(),
        config.doc.getroot(), 'ios', /*clobber=*/true);

    config.write();
    return config;
}

/**
 * Logs all file operations via the verbose event stream, indented.
 */
function logFileOp(message) {
    events.emit('verbose', '  ' + message);
}

/**
 * Updates platform 'www' directory by replacing it with contents of
 *   'platform_www' and app www. Also copies project's overrides' folder into
 *   the platform 'www' folder
 *
 * @param   {Object}  cordovaProject   An object which describes cordova project.
 * @param   {boolean} destinations     An object that contains destinations
 *   paths for www files.
 */
function updateWww(cordovaProject, destinations) {
    var sourceDirs = [
        path.relative(cordovaProject.root, cordovaProject.locations.www),
        path.relative(cordovaProject.root, destinations.platformWww)
    ];

    // If project contains 'merges' for our platform, use them as another overrides
    var merges_path = path.join(cordovaProject.root, 'merges', 'ios');
    if (fs.existsSync(merges_path)) {
        events.emit('verbose', 'Found "merges/ios" folder. Copying its contents into the iOS project.');
        sourceDirs.push(path.join('merges', 'ios'));
    }

    var targetDir = path.relative(cordovaProject.root, destinations.www);
    events.emit(
        'verbose', 'Merging and updating files from [' + sourceDirs.join(', ') + '] to ' + targetDir);
    FileUpdater.mergeAndUpdateDir(
        sourceDirs, targetDir, { rootDir: cordovaProject.root }, logFileOp);
}

/**
 * Cleans all files from the platform 'www' directory.
 */
function cleanWww(projectRoot, locations) {
    var targetDir = path.relative(projectRoot, locations.www);
    events.emit('verbose', 'Cleaning ' + targetDir);

    // No source paths are specified, so mergeAndUpdateDir() will clear the target directory.
    FileUpdater.mergeAndUpdateDir(
        [], targetDir, { rootDir: projectRoot, all: true }, logFileOp);
}

/**
 * Updates project structure and AndroidManifest according to project's configuration.
 *
 * @param   {ConfigParser}  platformConfig  A project's configuration that will
 *   be used to update project
 * @param   {Object}  locations       A map of locations for this platform (In/Out)
 */
function updateProject(platformConfig, locations) {

    // CB-6992 it is necessary to normalize characters
    // because node and shell scripts handles unicode symbols differently
    // We need to normalize the name to NFD form since iOS uses NFD unicode form
    var name = unorm.nfd(platformConfig.name());
    var pkg = platformConfig.ios_CFBundleIdentifier() || platformConfig.packageName();
    var version = platformConfig.version();

    var originalName = path.basename(locations.xcodeCordovaProj);

    // Update package id (bundle id)
    var plistFile = path.join(locations.xcodeCordovaProj, originalName + '-Info.plist');
    var infoPlist = plist.parse(fs.readFileSync(plistFile, 'utf8'));
    infoPlist['CFBundleIdentifier'] = pkg;

    // Update version (bundle version)
    infoPlist['CFBundleShortVersionString'] = version;
    var CFBundleVersion = platformConfig.ios_CFBundleVersion() || default_CFBundleVersion(version);
    infoPlist['CFBundleVersion'] = CFBundleVersion;

    // replace Info.plist ATS entries according to <access> and <allow-navigation> config.xml entries
    var ats = writeATSEntries(platformConfig);
    if (Object.keys(ats).length > 0) {
        infoPlist['NSAppTransportSecurity'] = ats;
    } else {
        delete infoPlist['NSAppTransportSecurity'];
    }

    handleOrientationSettings(platformConfig, infoPlist);

    var info_contents = plist.build(infoPlist);
    info_contents = info_contents.replace(/<string>[\s\r\n]*<\/string>/g,'<string></string>');
    fs.writeFileSync(plistFile, info_contents, 'utf-8');
    events.emit('verbose', 'Wrote out iOS Bundle Identifier "' + pkg + '" and iOS Bundle Version "' + version + '" to ' + plistFile);

    return handleBuildSettings(platformConfig, locations).then(function() {
        if (name == originalName) {
            events.emit('verbose', 'iOS Product Name has not changed (still "' + originalName + '")');
            return Q();
        }

        // Update product name inside pbxproj file
        var proj = new xcode.project(locations.pbxproj);
        try {
            proj.parseSync();
        } catch (err) {
            return Q.reject(new CordovaError('Could not parse project.pbxproj: ' + err));
        }

        proj.updateProductName(name);
        fs.writeFileSync(locations.pbxproj, proj.writeSync(), 'utf-8');

        // Move the xcodeproj and other name-based dirs over.
        shell.mv(path.join(locations.xcodeCordovaProj, originalName + '-Info.plist'), path.join(locations.xcodeCordovaProj, name + '-Info.plist'));
        shell.mv(path.join(locations.xcodeCordovaProj, originalName + '-Prefix.pch'), path.join(locations.xcodeCordovaProj, name + '-Prefix.pch'));
        // CB-8914 remove userdata otherwise project is un-usable in xcode
        shell.rm('-rf',path.join(locations.xcodeProjDir,'xcuserdata/'));
        shell.mv(locations.xcodeProjDir, path.join(locations.root, name + '.xcodeproj'));
        shell.mv(locations.xcodeCordovaProj, path.join(locations.root, name));

        // Update locations with new paths
        locations.xcodeCordovaProj = path.join(locations.root, name);
        locations.configXml = path.join(locations.xcodeCordovaProj, 'config.xml');
        locations.xcodeProjDir = path.join(locations.root, name + '.xcodeproj');
        locations.pbxproj = path.join(locations.xcodeProjDir, 'project.pbxproj');

        // Hack this shi*t
        var pbx_contents = fs.readFileSync(locations.pbxproj, 'utf-8');
        pbx_contents = pbx_contents.split(originalName).join(name);
        fs.writeFileSync(locations.pbxproj, pbx_contents, 'utf-8');
        events.emit('verbose', 'Wrote out iOS Product Name and updated XCode project file names from "'+originalName+'" to "' + name + '".');

        // Remove cached `projectFile` instance as it is not valid anymore
        // since the project structure has changed
        projectFile.purgeProjectFileCache(locations.root);

        return Q();
    });
}

function handleOrientationSettings(platformConfig, infoPlist) {

    switch (getOrientationValue(platformConfig)) {
        case 'portrait':
            infoPlist['UIInterfaceOrientation'] = [ 'UIInterfaceOrientationPortrait' ];
            infoPlist['UISupportedInterfaceOrientations'] = [ 'UIInterfaceOrientationPortrait', 'UIInterfaceOrientationPortraitUpsideDown' ];
            infoPlist['UISupportedInterfaceOrientations~ipad'] = [ 'UIInterfaceOrientationPortrait', 'UIInterfaceOrientationPortraitUpsideDown' ];
            break;
        case 'landscape':
            infoPlist['UIInterfaceOrientation'] = [ 'UIInterfaceOrientationLandscapeLeft' ];
            infoPlist['UISupportedInterfaceOrientations'] = [ 'UIInterfaceOrientationLandscapeLeft', 'UIInterfaceOrientationLandscapeRight' ];
            infoPlist['UISupportedInterfaceOrientations~ipad'] = [ 'UIInterfaceOrientationLandscapeLeft', 'UIInterfaceOrientationLandscapeRight' ];
            break;
        case 'all':
            infoPlist['UIInterfaceOrientation'] = [ 'UIInterfaceOrientationPortrait' ];
            infoPlist['UISupportedInterfaceOrientations'] = [ 'UIInterfaceOrientationPortrait', 'UIInterfaceOrientationPortraitUpsideDown', 'UIInterfaceOrientationLandscapeLeft', 'UIInterfaceOrientationLandscapeRight' ];
            infoPlist['UISupportedInterfaceOrientations~ipad'] = [ 'UIInterfaceOrientationPortrait', 'UIInterfaceOrientationPortraitUpsideDown', 'UIInterfaceOrientationLandscapeLeft', 'UIInterfaceOrientationLandscapeRight' ];
            break;
        case 'default':
            infoPlist['UISupportedInterfaceOrientations'] = [ 'UIInterfaceOrientationPortrait', 'UIInterfaceOrientationLandscapeLeft', 'UIInterfaceOrientationLandscapeRight' ];
            infoPlist['UISupportedInterfaceOrientations~ipad'] = [ 'UIInterfaceOrientationPortrait', 'UIInterfaceOrientationPortraitUpsideDown', 'UIInterfaceOrientationLandscapeLeft', 'UIInterfaceOrientationLandscapeRight' ];
            delete infoPlist['UIInterfaceOrientation'];
    }
}

function handleBuildSettings(platformConfig, locations) {
    var targetDevice = parseTargetDevicePreference(platformConfig.getPreference('target-device', 'ios'));
    var deploymentTarget = platformConfig.getPreference('deployment-target', 'ios');

    // no build settings provided, we don't need to parse and update .pbxproj file
    if (!targetDevice && !deploymentTarget) {
        return Q();
    }

    var proj = new xcode.project(locations.pbxproj);

    try {
        proj.parseSync();
    } catch (err) {
        return Q.reject(new CordovaError('Could not parse project.pbxproj: ' + err));
    }

    if (targetDevice) {
        events.emit('verbose', 'Set TARGETED_DEVICE_FAMILY to ' + targetDevice + '.');
        proj.updateBuildProperty('TARGETED_DEVICE_FAMILY', targetDevice);
    }

    if (deploymentTarget) {
        events.emit('verbose', 'Set IPHONEOS_DEPLOYMENT_TARGET to "' + deploymentTarget + '".');
        proj.updateBuildProperty('IPHONEOS_DEPLOYMENT_TARGET', deploymentTarget);
    }

    fs.writeFileSync(locations.pbxproj, proj.writeSync(), 'utf-8');

    return Q();
}

function mapIconResources(icons, iconsDir) {
    // See https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/IconMatrix.html
    // for launch images sizes reference.
    var platformIcons = [
        {dest: 'icon-60@2x.png', width: 120, height: 120},
        {dest: 'icon-60@3x.png', width: 180, height: 180},
        {dest: 'icon-76.png', width: 76, height: 76},
        {dest: 'icon-76@2x.png', width: 152, height: 152},
        {dest: 'icon-small.png', width: 29, height: 29},
        {dest: 'icon-small@2x.png', width: 58, height: 58},
        {dest: 'icon-40.png', width: 40, height: 40},
        {dest: 'icon-40@2x.png', width: 80, height: 80},
        {dest: 'icon-small@3x.png', width: 87, height: 87},
        {dest: 'icon.png', width: 57, height: 57},
        {dest: 'icon@2x.png', width: 114, height: 114},
        {dest: 'icon-72.png', width: 72, height: 72},
        {dest: 'icon-72@2x.png', width: 144, height: 144},
        {dest: 'icon-50.png', width: 50, height: 50},
        {dest: 'icon-50@2x.png', width: 100, height: 100},
        {dest: 'icon-83.5@2x.png', width: 167, height: 167}
    ];

    var pathMap = {};
    platformIcons.forEach(function (item) {
        var icon = icons.getBySize(item.width, item.height) || icons.getDefault();
        if (icon) {
            var target = path.join(iconsDir, item.dest);
            pathMap[target] = icon.src;
        }
    });
    return pathMap;
}

function getIconsDir(projectRoot, platformProjDir) {
    var iconsDir;
    var xcassetsExists = folderExists(path.join(projectRoot, platformProjDir, 'Images.xcassets/'));

    if (xcassetsExists) {
        iconsDir = path.join(platformProjDir, 'Images.xcassets/AppIcon.appiconset/');
    } else {
        iconsDir = path.join(platformProjDir, 'Resources/icons/');
    }

    return iconsDir;
}

function updateIcons(cordovaProject, locations) {
    var icons = cordovaProject.projectConfig.getIcons('ios');

    if (icons.length === 0) {
        events.emit('verbose', 'This app does not have icons defined');
        return;
    }

    var platformProjDir = path.relative(cordovaProject.root, locations.xcodeCordovaProj);
    var iconsDir = getIconsDir(cordovaProject.root, platformProjDir);
    var resourceMap = mapIconResources(icons, iconsDir);
    events.emit('verbose', 'Updating icons at ' + iconsDir);
    FileUpdater.updatePaths(
        resourceMap, { rootDir: cordovaProject.root }, logFileOp);
}

function cleanIcons(projectRoot, projectConfig, locations) {
    var icons = projectConfig.getIcons('android');
    if (icons.length > 0) {
        var platformProjDir = path.relative(projectRoot, locations.xcodeCordovaProj);
        var iconsDir = getIconsDir(projectRoot, platformProjDir);
        var resourceMap = mapIconResources(icons, iconsDir);
        Object.keys(resourceMap).forEach(function (targetIconPath) {
            resourceMap[targetIconPath] = null;
        });
        events.emit('verbose', 'Cleaning icons at ' + iconsDir);

        // Source paths are removed from the map, so updatePaths() will delete the target files.
        FileUpdater.updatePaths(
            resourceMap, { rootDir: projectRoot, all: true }, logFileOp);
    }
}

function mapSplashScreenResources(splashScreens, splashScreensDir) {
    var platformSplashScreens = [
        {dest: 'Default~iphone.png', width: 320, height: 480},
        {dest: 'Default@2x~iphone.png', width: 640, height: 960},
        {dest: 'Default-Portrait~ipad.png', width: 768, height: 1024},
        {dest: 'Default-Portrait@2x~ipad.png', width: 1536, height: 2048},
        {dest: 'Default-Landscape~ipad.png', width: 1024, height: 768},
        {dest: 'Default-Landscape@2x~ipad.png', width: 2048, height: 1536},
        {dest: 'Default-568h@2x~iphone.png', width: 640, height: 1136},
        {dest: 'Default-667h.png', width: 750, height: 1334},
        {dest: 'Default-736h.png', width: 1242, height: 2208},
        {dest: 'Default-Landscape-736h.png', width: 2208, height: 1242}
    ];

    var pathMap = {};
    platformSplashScreens.forEach(function (item) {
        var splash = splashScreens.getBySize(item.width, item.height);
        if (splash) {
            var target = path.join(splashScreensDir, item.dest);
            pathMap[target] = splash.src;
        }
    });
    return pathMap;
}

function getSplashScreensDir(projectRoot, platformProjDir) {
    var splashScreensDir;
    var xcassetsExists = folderExists(path.join(projectRoot, platformProjDir, 'Images.xcassets/'));

    if (xcassetsExists) {
        splashScreensDir = path.join(platformProjDir, 'Images.xcassets/LaunchImage.launchimage/');
    } else {
        splashScreensDir = path.join(platformProjDir, 'Resources/splash/');
    }

    return splashScreensDir;
}

function updateSplashScreens(cordovaProject, locations) {
    var splashScreens = cordovaProject.projectConfig.getSplashScreens('ios');

    if (splashScreens.length === 0) {
        events.emit('verbose', 'This app does not have splash screens defined');
        return;
    }

    var platformProjDir = path.relative(cordovaProject.root, locations.xcodeCordovaProj);
    var splashScreensDir = getSplashScreensDir(cordovaProject.root, platformProjDir);
    var resourceMap = mapSplashScreenResources(splashScreens, splashScreensDir);
    events.emit('verbose', 'Updating splash screens at ' + splashScreensDir);
    FileUpdater.updatePaths(
        resourceMap, { rootDir: cordovaProject.root }, logFileOp);
}

function cleanSplashScreens(projectRoot, projectConfig, locations) {
    var splashScreens = projectConfig.getSplashScreens('android');
    if (splashScreens.length > 0) {
        var platformProjDir = path.relative(projectRoot, locations.xcodeCordovaProj);
        var splashScreensDir = getSplashScreensDir(projectRoot, platformProjDir);
        var resourceMap = mapIconResources(splashScreens, splashScreensDir);
        Object.keys(resourceMap).forEach(function (targetSplashPath) {
            resourceMap[targetSplashPath] = null;
        });
        events.emit('verbose', 'Cleaning splash screens at ' + splashScreensDir);

        // Source paths are removed from the map, so updatePaths() will delete the target files.
        FileUpdater.updatePaths(
            resourceMap, { rootDir: projectRoot, all: true }, logFileOp);
    }
}

/**
 * Queries ConfigParser object for the orientation <preference> value. Warns if
 *   global preference value is not supported by platform.
 *
 * @param  {Object} platformConfig    ConfigParser object
 *
 * @return {String}           Global/platform-specific orientation in lower-case
 *   (or empty string if both are undefined).
 */
function getOrientationValue(platformConfig) {

    var ORIENTATION_DEFAULT = 'default';

    var orientation = platformConfig.getPreference('orientation');
    if (!orientation) {
        return '';
    }

    orientation = orientation.toLowerCase();

    // Check if the given global orientation is supported
    if (['default', 'portrait','landscape', 'all'].indexOf(orientation) >= 0) {
        return orientation;
    }

    events.emit('warn', 'Unrecognized value for Orientation preference: ' + orientation +
        '. Defaulting to value: ' + ORIENTATION_DEFAULT + '.');

    return ORIENTATION_DEFAULT;
}

/*
    Parses all <access> and <allow-navigation> entries and consolidates duplicates (for ATS).
    Returns an object with a Hostname as the key, and the value an object with properties:
        {
            Hostname, // String
            NSExceptionAllowsInsecureHTTPLoads, // boolean
            NSIncludesSubdomains,  // boolean
            NSExceptionMinimumTLSVersion, // String
             NSExceptionRequiresForwardSecrecy // boolean
        }
*/
function processAccessAndAllowNavigationEntries(config) {
    var accesses = config.getAccesses();
    var allow_navigations = config.getAllowNavigations();

    return allow_navigations
    // we concat allow_navigations and accesses, after processing accesses
    .concat(accesses.map(function(obj) {
        // map accesses to a common key interface using 'href', not origin
        obj.href = obj.origin;
        delete obj.origin;
        return obj;
    }))
    // we reduce the array to an object with all the entries processed (key is Hostname)
    .reduce(function(previousReturn, currentElement) {
        var obj = parseWhitelistUrlForATS(currentElement.href, currentElement.minimum_tls_version, currentElement.requires_forward_secrecy);
        if (obj) {
            // we 'union' duplicate entries
            var item = previousReturn[obj.Hostname];
            if (!item) {
                item = {};
            }
            for(var o in obj) {
                if (obj.hasOwnProperty(o)) {
                    item[o] = obj[o];
                }
            }
            previousReturn[obj.Hostname] = item;
        }
        return previousReturn;
    }, {});
}

/*
    Parses a URL and returns an object with these keys:
        {
            Hostname, // String
            NSExceptionAllowsInsecureHTTPLoads, // boolean (default: false)
            NSIncludesSubdomains,  // boolean (default: false)
            NSExceptionMinimumTLSVersion, // String (default: 'TLSv1.2')
            NSExceptionRequiresForwardSecrecy // boolean (default: true)
        }

    null is returned if the URL cannot be parsed, or is to be skipped for ATS.
*/
function parseWhitelistUrlForATS(url, minimum_tls_version, requires_forward_secrecy) {
    var href = URL.parse(url);
    var retObj = {};
    retObj.Hostname = href.hostname;

    if (url === '*') {
        return {
            Hostname : '*'
        };
    }

    // Guiding principle: we only set values in retObj if they are NOT the default

    if (!retObj.Hostname) {
        // check origin, if it allows subdomains (wildcard in hostname), we set NSIncludesSubdomains to YES. Default is NO
        var subdomain1 = '/*.'; // wildcard in hostname
        var subdomain2 = '*://*.'; // wildcard in hostname and protocol
        var subdomain3 = '*://'; // wildcard in protocol only
        if (href.pathname.indexOf(subdomain1) === 0) {
            retObj.NSIncludesSubdomains = true;
            retObj.Hostname = href.pathname.substring(subdomain1.length);
        } else if (href.pathname.indexOf(subdomain2) === 0) {
            retObj.NSIncludesSubdomains = true;
            retObj.Hostname = href.pathname.substring(subdomain2.length);
        } else if (href.pathname.indexOf(subdomain3) === 0) {
            retObj.Hostname = href.pathname.substring(subdomain3.length);
        } else {
            // Handling "scheme:*" case to avoid creating of a blank key in NSExceptionDomains.
            return null;
        }
    }

    if (minimum_tls_version && minimum_tls_version !== 'TLSv1.2') { // default is TLSv1.2
        retObj.NSExceptionMinimumTLSVersion = minimum_tls_version;
    }

    var rfs = (requires_forward_secrecy === 'true');
    if (requires_forward_secrecy && !rfs) { // default is true
        retObj.NSExceptionRequiresForwardSecrecy = false;
    }

    // if the scheme is HTTP, we set NSExceptionAllowsInsecureHTTPLoads to YES. Default is NO
    if (href.protocol === 'http:') {
        retObj.NSExceptionAllowsInsecureHTTPLoads = true;
    }
    else if (!href.protocol && href.pathname.indexOf('*:/') === 0) { // wilcard in protocol
        retObj.NSExceptionAllowsInsecureHTTPLoads = true;
    }

    return retObj;
}


/*
    App Transport Security (ATS) writer from <access> and <allow-navigation> tags
    in config.xml
*/
function writeATSEntries(config) {
  var pObj = processAccessAndAllowNavigationEntries(config);

    var ats = {};

    for(var hostname in pObj) {
        if (pObj.hasOwnProperty(hostname)) {
              if (hostname === '*') {
                  ats['NSAllowsArbitraryLoads'] = true;
                  continue;
              }

              var entry = pObj[hostname];
              var exceptionDomain = {};

              for(var key in entry) {
                  if (entry.hasOwnProperty(key) && key !== 'Hostname') {
                      exceptionDomain[key] = entry[key];
                  }
              }

              if (!ats['NSExceptionDomains']) {
                  ats['NSExceptionDomains'] = {};
              }

              ats['NSExceptionDomains'][hostname] = exceptionDomain;
        }
    }

    return ats;
}

function folderExists(folderPath) {
    try {
        var stat = fs.statSync(folderPath);
        return stat && stat.isDirectory();
    } catch (e) {
        return false;
    }
}

// Construct a default value for CFBundleVersion as the version with any
// -rclabel stripped=.
function default_CFBundleVersion(version) {
    return version.split('-')[0];
}

// Converts cordova specific representation of target device to XCode value
function parseTargetDevicePreference(value) {
    if (!value) return null;
    var map = { 'universal': '"1,2"', 'handset': '"1"', 'tablet': '"2"'};
    if (map[value.toLowerCase()]) {
        return map[value.toLowerCase()];
    }
    events.emit('warn', 'Unrecognized value for target-device preference: ' + value + '.');
    return null;
}
